<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  line-height: 0;
}

body > * {
  line-height: 1.2em;
}

.chart-container {
  overflow-y: auto;
  overflow-x: hidden;
  line-height: 0;
}

.chart_container > * {
  line-height: 1.2em;
}

.legend .x-axis text {
  fill: black;
  font: 10px sans-serif;
  text-anchor: start;
  transform: rotate(-8deg);
}

.axis .domain {
  display: none;
}

.chart .y-axis .tick > line {
  opacity: 0.1;
}

.chart .x-axis text {
  display: none;
}

.chart .data-area .log-entry .main-rect-fill {
  fill: white;
}

.chart .data-area .log-entry .main-rect-stroke {
  stroke: black;
  stroke-width: 1px;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  fill: none;
}

.chart .data-area .log-entry .duration line {
  stroke: black;
  stroke-width: 2px;
}

.detail {
  display: block;
  white-space: pre-wrap;
  word-break: break-all;
  margin: 0 4px;
  padding: 8px;
  border: 1px solid black;
  box-sizing: border-box;
  border-radius: 3px;
}

</style>
<body>
<svg class="legend"></svg>
<div class="chart-container">
  <svg class="chart"></svg>
</div>
<script src="https://d3js.org/d3.v4.js" charset="utf-8"></script>
<script src="log_data.jsonp" charset="utf-8"></script>
<script>
var logentry_get_duration = function (log_entry) {
  if (log_entry._source.requestTime != null) {
    return log_entry._source.requestTime * 1000;
  }
  if (log_entry._source.api_time != null) {
    return log_entry._source.api_time * 1000;
  }
  return null;
};

var type_sort_key = function (type_string) {
  return type_string.split("-").map(function (fragment) {
    return {
      "nginx": "!a",
      "router": "!a",
      "api": "~z",
      "application": "~z",
      "search": "~z" // would actually be part of "search-api"
    }[fragment] || fragment;
  }).join("-");
}

var logentry_get_start_time = function (log_entry) {
  var duration = logentry_get_duration(log_entry);
  return duration && log_entry._timestamp_ms - duration;
};

var logentry_get_earliest_time = function (log_entry) {
  return logentry_get_start_time(log_entry) || log_entry._timestamp_ms;
};


var data = window.log_data.hits.hits;
data.forEach(function (log_entry) {
  log_entry["_timestamp_ms"] = (new Date(log_entry._source["@timestamp"])).getTime();
});
data.sort(function(a, b) {
  return b._timestamp_ms - a._timestamp_ms;
});
var data_by_type = d3.nest().key(function(log_entry) { return log_entry._type; }).entries(data);

data_by_type.sort(function (a, b) {
  var sort_key_a = type_sort_key(a.key);
  var sort_key_b = type_sort_key(b.key);
  if (sort_key_a > sort_key_b) {
    return 1;
  } else if (sort_key_a < sort_key_b) {
    return -1;
  } else {
    return 0;
  }
});

var chart_margin = {top: 2, right: 0, bottom: 10, left: 32};
var legend_margin = {top: 0, right: 0, bottom: 0, left: 32};
var type_width = 96;
var get_inner_width = function() { return type_width * data_by_type.length };
var get_outer_width = function() { return get_inner_width() + chart_margin.left + chart_margin.right };
var chart_container_height = 500;
var chart_height = 500;
var get_inner_height = function() { return chart_height - (chart_margin.top + chart_margin.bottom) };
var preferred_duration_spacing = 6;
var main_rect_width = 32;

var y_scale = d3.scaleTime()
  .domain([
    d3.min(data, function(log_entry) { return logentry_get_earliest_time(log_entry)}),
    d3.max(data, function(log_entry) { return log_entry._timestamp_ms})
  ]).range([0, get_inner_height()]);
var y_axis = d3.axisLeft(y_scale)
  .ticks(chart_height/50)
  .tickSize(-get_inner_width());

var x_scale = d3.scaleOrdinal(data_by_type.map(function(d, i) { return (i+0.5) * type_width; }))
  .domain(data_by_type.map(function(d, i) { return d.key; }));
var x_axis_inner = d3.axisTop(x_scale).tickSize(-get_inner_height());
var x_axis_outer = d3.axisTop(x_scale).tickSize(0);

var chart_container = d3.select(".chart-container")
  .style("height", chart_container_height + "px")
  .style("width", get_outer_width() + "px");

var chart = d3.select(".chart");
var chart_inner = chart.append("g")
  .attr("class", "chart-inner")
  .attr("transform", "translate(" + chart_margin.left + " " + chart_margin.top + ")");
var chart_x_axis = chart_inner.append("g")
  .attr("class", "axis x-axis");
var chart_y_axis = chart_inner.append("g")
  .attr("class", "axis y-axis");
var chart_data_area = chart_inner.append("g")
  .attr("class", "data-area");

var legend = d3.select(".legend")
  .attr("width", get_outer_width())
  .attr("height", 32);
var legend_inner = legend.append("g")
  .attr("class", "chart-inner")
  .attr("transform", "translate(" + legend_margin.left + " " + 32 + ")");
var legend_x_axis = legend_inner.append("g")
  .attr("class", "axis x-axis");

chart_data_area.selectAll("g").data(data_by_type, function(type_group) { return type_group.key; }).enter().append("g")
  .attr("class", "type-group");

var log_entry_g_enter = chart_data_area.selectAll("g").selectAll("g.log-entry").data(
  function(parent_datum) {
    parent_datum.values.forEach(function(log_entry, i) { log_entry._order_in_type = i; });
    return parent_datum.values;
  },
  function(log_entry) { return log_entry._id; }
).enter().append("g")
  .attr("class", "log-entry")
  .on("mouseover", function() {
    this.parentNode.appendChild(this);

    var detail = d3.select("body").selectAll("pre.detail").data([d3.select(this).datum()]);
    var detail_enter = detail.enter().append("pre").attr("class", "detail");
    detail = detail_enter.merge(detail);
    detail.text(function(d) { return JSON.stringify(d._source, null, 2); })
      .style("width", (get_outer_width()-8) + "px");
  })
  .on("mouseleave", function() {
    var order_in_type = d3.select(this).datum()._order_in_type;
    if (order_in_type != null) {
      this.parentNode.insertBefore(
        this,
        order_in_type >= this.parentNode.childNodes.length ? null : this.parentNode.childNodes[order_in_type]
      );
    }
  });

var duration_g_enter = log_entry_g_enter.append("g").attr("class", "duration");
duration_g_enter.append("line")
  .attr("class", "duration-h")
  .attr("x1", -4)
  .attr("y1", 0)
  .attr("x2", 4)
  .attr("y2", 0);
duration_g_enter.append("line")
  .attr("class", "duration-v")
  .attr("x1", 0)
  .attr("y1", 0)
  .attr("x2", 0);

log_entry_g_enter.append("rect").attr("class", "main-rect-fill")
  .attr("x", -main_rect_width/2)
  .attr("y", 0)
  .attr("width", main_rect_width)
  .attr("height", 8);
log_entry_g_enter.append("rect").attr("class", "severity-stripe")
  .attr("x", -main_rect_width/2)
  .attr("y", 0)
  .attr("width", 6)
  .attr("height", 8);
log_entry_g_enter.append("path").attr("class", "main-rect-stroke")
  .attr("d", "M" + -((6+main_rect_width)/2) + ",0h" + (main_rect_width+6) + "M" + (main_rect_width/2) + ",0v8h" + -main_rect_width + "v-8");

chart.on("wheel", function() {
  if (d3.event.ctrlKey) {
    d3.event.preventDefault();
    chart_height = chart_height * Math.pow(2, d3.event.deltaY/3); 
    y_scale.range([0, get_inner_height()]);
    perform_updates();
  }
});

var perform_updates = function (type_line_g, log_entry_g) {
  var type_line_g = type_line_g || chart_data_area.selectAll("g.type-group");
  // remembering to do this nested select to get our grouping behaviour
  var log_entry_g = log_entry_g || chart_data_area.selectAll("g.type-group").selectAll("g.log-entry");

  chart.attr("width", get_outer_width()).attr("height", chart_height);
  chart_x_axis.call(x_axis_inner);
  legend_x_axis.call(x_axis_outer);
  chart_y_axis.call(y_axis);

  type_line_g.attr("transform", function(d) { return "translate(" + x_scale(d.key) + ", 0)"; });

  log_entry_g.attr("transform", function(d) { return "translate(0, " + y_scale(d._timestamp_ms) + ")"; });
  log_entry_g.select(".duration")
    .style("display", function(d) { return logentry_get_duration(d) ? "inline" : "none"; })
    .filter(function(d) { return logentry_get_duration(d); })
      .attr("transform", function(d, i, nodes) {
        return "translate(" + (
          (Math.ceil((nodes.length-1)/2) - i) * Math.min(main_rect_width/nodes.length, preferred_duration_spacing)
        ) + ", " + (y_scale(logentry_get_start_time(d)) - y_scale(d._timestamp_ms)) + ")";
      })
      .select(".duration-v")
        .attr("y2", function(d) {
          return y_scale(d._timestamp_ms) - y_scale(logentry_get_start_time(d));
        });
  log_entry_g.select(".severity-stripe")
    .attr("fill", function(d) {
      return {
        "DEBUG": "#cccccc",
        "WARNING": "orange",
        "ERROR": "red"
      }[d._source.levelname] || "transparent";
    });
};
perform_updates();

</script>
</body>
