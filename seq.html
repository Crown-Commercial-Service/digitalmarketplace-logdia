<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  line-height: 0;
}

body > * > * {
  line-height: 1.2em;
}

.chart-container {
  overflow-y: auto;
  overflow-x: hidden;
  line-height: 0;
}

.chart_container > * {
  line-height: 1.2em;
}

.legend .x-axis text {
  fill: black;
  font: 10px sans-serif;
  text-anchor: start;
  transform: rotate(-8deg);
}

.axis .domain {
  display: none;
}

.chart .y-axis .tick > line {
  opacity: 0.1;
}

.chart .x-axis text {
  display: none;
}

* {
  transition: transform 100ms linear;
}

.chart .data-area .log-entry .main-rect-fill {
  fill: white;
}

.chart .data-area .log-entry .main-rect-stroke {
  stroke: black;
  stroke-width: 1px;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  fill: none;
}

.chart .data-area .log-entry .duration line {
  stroke: black;
  stroke-width: 2px;
}

.detail {
  display: block;
  white-space: pre-wrap;
  word-break: break-all;
  margin: 0 4px;
  padding: 8px;
  border: 1px solid black;
  box-sizing: border-box;
  border-radius: 3px;
  width: 650px;
}

textarea {
  width: 650px;
}

</style>
<body>
<div id="visualization">
  <svg class="legend"></svg>
  <div class="chart-container">
    <svg class="chart">
      <defs>
        <filter y="-50%" height="200%" id="halo">
          <feColorMatrix result="matrixOut" in="SourceAlpha" type="matrix" values="0 0 0 0 1  0 0 0 0 1  0 0 0 0 1  0 0 0 0.7 0"/>
          <feMorphology in="matrixOut" result="morphOut" operator="dilate" radius="2" />
          <feBlend in="SourceGraphic" in2="morphOut" mode="normal"/>
        </filter>
      </defs>
    </svg>
  </div>
</div>
<form id="src-data-form">
  <textarea name="src-data-json" rows="20"></textarea>
  <button type="submit">Update</button>
</form>
<script src="https://d3js.org/d3.v4.js" charset="utf-8"></script>
<script>
var logentry_get_duration = function (log_entry) {
  if (log_entry._source.requestTime != null) {
    return log_entry._source.requestTime * 1000;
  }
  if (log_entry._source.api_time != null) {
    return log_entry._source.api_time * 1000;
  }
  return null;
};

var type_sort_key = function (type_string) {
  return type_string.split("-").map(function (fragment) {
    return {
      "nginx": "!a",
      "router": "!a",
      "api": "~z",
      "application": "~z",
      "search": "~z" // would actually be part of "search-api"
    }[fragment] || fragment;
  }).join("-");
}

var type_sort_comparator = function (a, b) {
  var sort_key_a = type_sort_key(a.key);
  var sort_key_b = type_sort_key(b.key);
  if (sort_key_a > sort_key_b) {
    return 1;
  } else if (sort_key_a < sort_key_b) {
    return -1;
  } else {
    return 0;
  }
};

var log_level_name_color_function = function(log_level_name) {
  return {
    "DEBUG": "#bbbbbb",
    "WARNING": "orange",
    "ERROR": "red"
  }[log_level_name];
};

var http_status_color_function = function(status) {
  var status_string = status + "";
  if (status_string.startsWith("3")) {
    return "purple";
  } else if (status_string.startsWith("4")) {
    return "orange";
  } else if (status_string.startsWith("5")) {
    return "red";
  }
}

var left_stripe_fill_function = function(log_entry) {
  return log_level_name_color_function(log_entry._source.levelname) ||
    http_status_color_function(log_entry._source.status) ||
    "transparent";
};

var right_stripe_fill_function = function(log_entry) {
  return http_status_color_function(log_entry._source.api_status) ||
    "transparent";
};

var log_entry_g_id_function = function (log_entry) {
  return "log-entry-" + log_entry._id;
};

var logentry_get_start_time = function (log_entry) {
  var duration = logentry_get_duration(log_entry);
  return duration && log_entry._timestamp_ms - duration;
};

var logentry_get_earliest_time = function (log_entry) {
  return logentry_get_start_time(log_entry) || log_entry._timestamp_ms;
};

var mk_x_scale = function(nested_data) {
  return d3.scaleOrdinal(nested_data.map(function(d, i) { return (i+0.5) * type_width; }))
  .domain(nested_data.map(function(d, i) { return d.key; }));
}

// convert an svg transform= attribute into an inline css style (mainly involves adding "px" where necessary)
var transform_to_style = function (selection) {
  selection.filter("[transform]").style("transform", function() {
    return this.attributes.transform.value.replace(/([0-9.])\s*\,/, "$1px,").replace(/([0-9.])\s*\)/, "$1px)");
  }).attr("transform", null);
};

var data;
var data_by_type;
var data_multiple_request_ids;
var chart_margin = {top: 2, right: 0, bottom: 10, left: 32};
var legend_margin = {top: 0, right: 0, bottom: 0, left: 32};
var type_width = 96;
var get_inner_width = function() { return type_width * data_by_type.length };
var get_outer_width = function() { return get_inner_width() + chart_margin.left + chart_margin.right };
var chart_container_height = 500;
var chart_height = 500;
var get_inner_height = function() { return chart_height - (chart_margin.top + chart_margin.bottom) };
var preferred_duration_spacing = 6;
var main_rect_width = 32;

var y_scale = d3.scaleTime();
var y_axis = d3.axisLeft(y_scale);

var x_scale_inner;
var x_scale_outer;
var x_axis_inner;
var x_axis_outer;

var chart_container = d3.select(".chart-container");

var chart = d3.select(".chart");
var chart_inner = chart.append("g")
  .attr("class", "chart-inner");
var chart_x_axis = chart_inner.append("g")
  .attr("class", "axis x-axis");
var chart_y_axis = chart_inner.append("g")
  .attr("class", "axis y-axis");
var chart_data_area = chart_inner.append("g")
  .attr("class", "data-area");

var legend = d3.select(".legend");
var legend_inner = legend.append("g")
  .attr("class", "chart-inner");
var legend_x_axis = legend_inner.append("g")
  .attr("class", "axis x-axis");

chart.on("wheel", function() {
  if (d3.event.ctrlKey) {
    d3.event.preventDefault();

    var deltaY_normalized = d3.event.deltaY * {
      "0": 0.02,  // unit is pixels
      "1": 1./3,  // unit is lines
      "2": 1      // unit is pages
                  // ^ of course, the above have no literal meaning when zooming, so we've just got to
                  // weight them approximately
    }[d3.event.deltaMode];

    chart_height = Math.min(Math.max(chart_container_height, chart_height * Math.pow(2, -deltaY_normalized)), chart_container_height*16);

    zoom_updated();
  }
});

var src_data_form = d3.select("#src-data-form")
  .on("submit", function() {
    d3.event.preventDefault();
    var new_data = JSON.parse(this.elements["src-data-json"].value);
    data = new_data.hits.hits
    data_updated();
  });

var highlights_updated = function () {
  var highlight_g = chart_data_area.selectAll("g.type-group").select(".highlight-container").selectAll("g.highlight").data(
    function(parent_datum) {
      return parent_datum.highlight;
    },
    function(log_entry) { return log_entry._id; }
  );
  // rather than delete the highlight let's keep it around as it may be needed again
  highlight_g.exit().style("display", "none");
  var highlight_g_enter = highlight_g.enter().append("g")
    .attr("class", "highlight")
    .on("mouseleave", function () {
      // this event is occasionally missed, leaving a stale highlight mirror around
      d3.select(this.parentNode).datum().highlight = [];
      highlights_updated();
    });
  if (!window.sidebar) {  // only firefox has this defined
    // only apply filter to highlight if we know we're not firefox - it has a rendering bug
    // causing the entire highlight to be invisible if filtered
    highlight_g_enter.attr("filter", "url(#halo)");
  }
  highlight_g_enter.append("use")
    .attr("class", "highlight-mirror");
  highlight_g_enter.append("line")
    .attr("class", "time-line time-line-end");

  highlight_g = highlight_g.merge(highlight_g_enter);
  highlight_g.style("display", "inline")
    .select("use").attr("href", function(log_entry) { return "#" + log_entry_g_id_function(log_entry); });
};

var data_updated = function () {
  data_multiple_request_ids = !data.every(function (log_entry) {
    return log_entry._source.requestId === data[0]._source.requestId;
  });
  data.forEach(function (log_entry) {
    log_entry["_timestamp_ms"] = (new Date(log_entry._source["@timestamp"])).getTime();
  });
  data.sort(function(a, b) {
    return b._timestamp_ms - a._timestamp_ms;
  });
  data_by_type = d3.nest().key(function(log_entry) { return log_entry._type; }).entries(data);
  data_by_type.forEach(function (type_group) {
    type_group.highlight = [];
  });
  data_by_type.sort(type_sort_comparator);

  y_scale.domain([
    d3.min(data, function(log_entry) { return logentry_get_earliest_time(log_entry)}),
    d3.max(data, function(log_entry) { return log_entry._timestamp_ms})
  ]);
  y_axis.tickSize(-get_inner_width());
  // it doesn't look like a scale can be shared between two axis - if you do, drawing one axis affects the other, so
  // we have two "identical" x scales here
  x_scale_inner = mk_x_scale(data_by_type);
  x_scale_outer = mk_x_scale(data_by_type);
  x_axis_inner = d3.axisTop(x_scale_inner);
  x_axis_outer = d3.axisTop(x_scale_outer).tickSize(0);

  chart_container.style("height", chart_container_height + "px")
    .style("width", get_outer_width() + "px");
  chart_inner.style("transform", "translate(" + chart_margin.left + "px, " + chart_margin.top + "px)");

  legend.attr("width", get_outer_width())
    .attr("height", 32);
  legend_inner.style("transform", "translate(" + legend_margin.left + "px, " + 32 + "px)");

  var type_group_g = chart_data_area.selectAll("g.type-group").data(data_by_type, function(type_group) { return type_group.key; });
  var type_group_g_enter = type_group_g.enter().append("g")
    .attr("class", "type-group");
  type_group_g_enter.append("g")
      .attr("class", "log-entry-container");
  type_group_g_enter.append("g")
      .attr("class", "highlight-container");
  type_group_g.exit().remove();

  var log_entry_g = chart_data_area.selectAll("g.type-group").select(".log-entry-container").selectAll("g.log-entry").data(
    function(parent_datum) {
      parent_datum.values.forEach(function(log_entry, i) { log_entry._order_in_type = i; });
      return parent_datum.values;
    },
    function(log_entry) { return log_entry._id; }
  );
  var log_entry_g_enter = log_entry_g.enter().append("g")
    .attr("class", "log-entry")
    .attr("id", log_entry_g_id_function)
    .on("mouseover", function() {
      d3.select(this.parentNode).datum().highlight = [d3.select(this).datum()];
      highlights_updated();

      var detail = d3.select("#visualization").selectAll("pre.detail").data([d3.select(this).datum()]);
      var detail_enter = detail.enter().append("pre").attr("class", "detail");
      detail = detail_enter.merge(detail);
      detail.text(function(d) { return JSON.stringify(d._source, null, 2); });
    })
  log_entry_g.exit().remove();
  // set this back to the combined group
  log_entry_g = log_entry_g.merge(log_entry_g_enter);

  var duration_g_enter = log_entry_g_enter.append("g").attr("class", "duration");
  duration_g_enter.append("line")
    .attr("class", "duration-h")
    .attr("x1", -4)
    .attr("y1", 0)
    .attr("x2", 4)
    .attr("y2", 0);
  duration_g_enter.append("line")
    .attr("class", "duration-v")
    .attr("x1", 0)
    .attr("y1", 0)
    .attr("x2", 0)
    .attr("y2", 1);  // actual height will end up getting defined by a transform because that's transitionable

  log_entry_g_enter.append("rect").attr("class", "main-rect-fill")
    .attr("x", -main_rect_width/2)
    .attr("y", 0)
    .attr("width", main_rect_width)
    .attr("height", 8);
  log_entry_g_enter.append("rect").attr("class", "left-stripe")
    .attr("x", -main_rect_width/2)
    .attr("y", 0)
    .attr("width", 6)
    .attr("height", 8);
  log_entry_g_enter.append("rect").attr("class", "right-stripe")
    .attr("x", (main_rect_width/2)-6)
    .attr("y", 0)
    .attr("width", 6)
    .attr("height", 8);
  log_entry_g_enter.append("path").attr("class", "main-rect-stroke")
    .attr("d", "M" + -((6+main_rect_width)/2) + ",0h" + (main_rect_width+6) + "M" + (main_rect_width/2) + ",0v8h" + -main_rect_width + "v-8");

  log_entry_g.select(".main-rect-fill")
    .style("fill", function(d) {
      if (data_multiple_request_ids) {
        try {
          return d3.hsl(parseInt(d._source.requestId.substr(-2), 16), 0.7, 0.9).toString();
        } catch (e) {}
      }
      return null;
    });
  log_entry_g.select(".left-stripe")
    .attr("fill", left_stripe_fill_function);
  log_entry_g.select(".right-stripe")
    .attr("fill", right_stripe_fill_function);

  zoom_updated();
};

var zoom_updated = function (type_line_g, log_entry_g) {
  var type_line_g = type_line_g || chart_data_area.selectAll("g.type-group");
  // remembering to do this nested select to get our grouping behaviour
  var log_entry_g = log_entry_g || chart_data_area.selectAll("g.type-group").selectAll("g.log-entry");

  chart.attr("width", get_outer_width());
  // we only want to set the new height before the scroll calculation if it's *greater than* the
  // existing height. the scroll calculation needs all the headroom available to it
  chart.attr("height", Math.max(chart_height, parseInt(chart.attr("height")) || 0));

  var y_original_range = y_scale.range();
  var y_original_range_upper = y_original_range && y_original_range[1];
  var original_scrollTop = chart_container.node().scrollTop;
  if (y_original_range_upper !== get_inner_height()) {
    var fixed_point_px;
    try {
      fixed_point_px = d3.mouse(chart_container.node())[1];
    } catch (e) {
      fixed_point_px = chart_container_height/2;
    }
    var fixed_point_ts = y_scale.invert(original_scrollTop + fixed_point_px - chart_margin.top);

    y_scale.range([0, get_inner_height()]);

    chart_container.node().scrollTop = y_scale(fixed_point_ts) + chart_margin.top - fixed_point_px;
  }
  var scrollTop_delta = chart_container.node().scrollTop - original_scrollTop;

  // now make sure our height is ultimately set to the desired value
  chart.attr("height", chart_height);

  y_axis.ticks(chart_height/50);
  x_axis_inner.tickSize(-get_inner_height());

  chart_x_axis.call(x_axis_inner);
  transform_to_style(chart_x_axis.selectAll(".tick"));
  legend_x_axis.call(x_axis_outer);
  transform_to_style(legend_x_axis.selectAll(".tick"));
  chart_y_axis.call(y_axis);
  transform_to_style(chart_y_axis.selectAll(".tick"));

  type_line_g.style("transform", function(d) { return "translate(" + x_scale_inner(d.key) + "px, 0px)"; });

  if (scrollTop_delta) {
    // the calculation and setting of the new scrollTop value will have moved the log_entry_g's positions
    // up or down the page. however we need the elements to appear to move from their previous position
    // *on screen* to the new one to make the animation appear correct. so before we allow the transition
    // to take place, we need to move log_entry_g's to a scrollTop-compensated position to get them back in
    // their previous screen position.
    // first we need to disable the transition because we want this move to happen invisibly (preferably don't
    // want the uncompensated position to be rendered at all)
    log_entry_g.style("transition", "none");
    // now add the compensation
    log_entry_g.style("transform", function(d, i, nodes) {
      return "translate(0px, " + ((this._seqdia_y_translation || 0) + scrollTop_delta) + "px)";
    });
    // trick layout into being recalculated for these elements before we give them back their transition
    log_entry_g.each(function () { window.getComputedStyle ( this ).transform });
    // allow transition to return to its stylesheet-set value
    log_entry_g.style("transition", null);
  }

  log_entry_g.style("transform", function(d, i, nodes) {
    // make a easily readable memo of the current set value (parsing it back out from a translate() string
    // is painful...)
    this._seqdia_y_translation = y_scale(d._timestamp_ms);
    return "translate(0px, " + this._seqdia_y_translation + "px)"; }
  );
  log_entry_g.select(".duration")
    .style("display", function(d) { return logentry_get_duration(d) ? "inline" : "none"; })
    .filter(function(d) { return logentry_get_duration(d); })
      .style("transform", function(d, i, nodes) {
        return "translate(" + (
          (Math.ceil((nodes.length-1)/2) - i) * Math.min(main_rect_width/nodes.length, preferred_duration_spacing)
        ) + "px, " + (y_scale(logentry_get_start_time(d)) - y_scale(d._timestamp_ms)) + "px)";
      })
      .select(".duration-v")
        .style("transform", function(d) {
          return "scale(1, " + (y_scale(d._timestamp_ms) - y_scale(logentry_get_start_time(d))) + ")";
        });
};

</script>
</body>
